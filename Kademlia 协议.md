### Kademlia 协议

##### 1、简介

Kademlia 是分布式散列表（DHT，Distributed Hash Table）的一种，类似的还有 Chord，Pastry 等。Kademlia算法是一种分布式存储及路由的算法。

##### 2、引入

分布式存储举例：
	    假设一所学校有1000人，现在学校突然决定拆掉图书馆（不设立中心化的服务器），将图书馆里所有的书都分发到每位学生手上（所有的文件分散存储在各个节点上）。即是所有的学生，共同组成了一个分布式的图书馆。	

![947209-795f3af7231108b7](C:\Users\Administrator\Desktop\Kad\947209-795f3af7231108b7.png)

<center><h7>由中心化图书馆到分布式图书馆</h7></center>

现在面临如下问题需要解决：

* 每个同学手上都分配哪些书。即如何分配存储内容到各个节点，新增/删除内容如何处理。
* 当你需要找到一本书，譬如《韭菜的自我修养》的时候，如何知道哪位同学手上有《韭菜的自我修养》（对1000个人挨个问一遍，“你有没有《韭菜的自我修养》？”，显然是个不经济的做法），又如何联系上这位同学。即一个节点如果想获取某个特定的文件，如何找到存储文件的节点/地址/路径。

![947209-8b12f9959fa3144f](C:\Users\Administrator\Desktop\Kad\947209-8b12f9959fa3144f.png)

<center><h7>如何找到需要的书籍</h7></center>

##### 3、Kademlia是如何解决上面问题的

节点要素：

* 学号（Node ID，2进制，160位）

* 手机号码（节点的IP地址及端口）

每位同学维护以下内容：

  * 从图书馆分发下来的书本（被分配到需要存储的内容），每本书当然都有书名和书本内容（内容以<key, value>对的形式存储，可以理解为文件名和文件内容）。
  * 一个通讯录，包含一小部分其他同学的学号和手机号，通讯录按学号分层（一个路由表，称为“k-bucket”，按Node ID分层，记录有限个数的其他节点的ID和IP地址及端口）。概念类比如下图：	  

​					![）947209-ac0338100a380c61](C:\Users\Administrator\Desktop\Kad\947209-ac0338100a380c61.png)

 原来收藏在图书馆里，按索引号码得整整齐齐的书，以一种什么样的方式分发到同学们手里呢？原则如下：

* 书本能够比较均衡地分布在同学们的手里，不会出现部分同学手里书特别多、而大部分同学连一本书都没有的情况。
* 同学想找一本特定的书的时候，能够一种相对简单的索引方式找到这本书。

Kademlia 做了如下安排：

​		假设《韭菜的自我修养》这本书的书名的hash值是 *00010000*，那么这本书就会被要求存在学号为*00010000*的同学手上。但还得考虑到会有同学缺勤。万一*00010000*今天没来上学（节点没有上线或彻底退出网络），那《韭菜的自我修养》这本书岂不是谁都拿不到了？那算法要求这本书不能只存在一个同学手上，而是被要求同时存储在学号最接近*00010000*的k位同学手上，即*00010001*、*00010010*、*00010011*…等同学手上都会有这本书。

​		同样地，当你需要找《韭菜的自我修养》这本书时，将书名hash一下，得到 *00010000*，这个便是索书号，你就知道该找哪（几）位同学了。剩下的问题，就是找到这（几）位同学的手机号。

![947209-54dfcb165392638e_meitu_1](C:\Users\Administrator\Desktop\Kad\947209-54dfcb165392638e_meitu_1.jpg)

<center><h7>书籍搜索定位</h7></center>

节点的异或距离：

​		 由于你手上只有一部分同学的通讯录，你很可能并没有*00010000*的手机号（IP地址）。那如何联系上目标同学呢？

​		  一个可行的思路就是在你的通讯录里找到一位拥有目标同学的联系方式的同学。前面提到，每位同学手上的通讯录都是按距离分层的。算法的设计是，如果一个同学离你越近，你手上的通讯录里存有ta的手机号码的概率越大。而算法的核心的思路就可以是：当你知道目标同学Z与你之间的距离，你可以在你的通讯录上先找到一个你认为与同学Z最相近的同学B，请同学B再进一步去查找同学Z的手机号。

通讯录按距离分层：

​	按异或距离分层，基本上可以理解为按位数分层。设想以下情景：

​			以*0000110*为基础节点，如果一个节点的ID，前面所有位数都与它相同，只有最后1位不同，这样的节点只有1个——*0000111*，与基础节点的异或值为*0000001*，即距离为1；对于*0000110*而言，这样的节点归为**“k-bucket 1”**；

​			如果一个节点的ID，前面所有位数相同，从倒数第2位开始不同，这样的节点只有2个：*0000101*、*0000100*，与基础节点的异或值为*0000011*和*0000010*，即距离范围为3和2；对于*0000110*而言，这样的节点归为**“k-bucket 2”**；

​			........

​			如果一个节点的ID，前面所有位数相同，从倒数第n位开始不同，这样的节点只有2^(i-1)个，与基础节点的距离范围为[2^(i-1), 2^(i)）；对于*0000110*而言，这样的节点归为**“k-bucket i”**；

![947209-6bdd6e96a80d0780](C:\Users\Administrator\Desktop\Kad\947209-6bdd6e96a80d0780.png)

<center><h7>按位数区分k-bucket</h7></center>

​			对上面描述的另一种理解方式：如果将整个网络的节点梳理为一个按节点ID排列的二叉树，树最末端的每个叶子便是一个节点，则下图就比较直观的展现出，节点之间的距离的关系。

![947209-c12846900b0525db](C:\Users\Administrator\Desktop\Kad\947209-c12846900b0525db.png)

<center><h7>k-bucket示意图：右下角的黑色实心圆，为基础节</h7></center>

回到类比：

​	    每个同学只维护一部分的通讯录，这个通讯录按照距离分层（可以理解为按学号与自己的学号从第几位开始不同而分层），即k-bucket1, k-bucket 2, k-bucket 3…虽然每个k-bucket中实际存在的同学人数逐渐增多，但每个同学在它自己的每个k-bucket中只记录k位同学的手机号（k个节点的地址与端口，这里的k是一个可调节的常量参数）。

​	   由于学号（节点的ID）有160位，所以每个同学的通讯录中共分160层（节点共有160个k-bucket）。整个网络最多可以容纳2^160个同学（节点），但是每个同学（节点）最多只维护160 * k 行通讯录（其他节点的地址与端口）。

节点定位：

​		现在来讲解一个完整的搜索过程：

​			    A同学（学号*00000110*）想找《韭菜的自我修养》，A首先需要计算书名的哈希值，hash(《韭菜的自我修养》) = *00010000*。那么A就知道ta需要找到*00010000*号同学（命名为Z同学）或学号与Z邻近的同学。
 Z的学号*00010000*与自己的异或距离为 *00010110*，距离范围在[24, 25)，所以这个Z同学可能在k-bucket 5中（或者说，Z同学的学号与A同学的学号从第5位开始不同，所以Z同学可能在k-bucket 5中）。

​				然后A同学看看自己的k-bucket 5有没有Z同学：

​					    -- 如果有，那就联系Z同学要书

​						-- 如果没有，在k-bucket 5里随便找一个B同学（注意任意B同学，它的学号第5位肯定与Z相同，即它与Z同学的距离会小于24，相当于比Z、A之间的距离缩短了一半以上），请求B同学在它自己的通讯录里按同样的查找方式找一下Z同学：

​								    -- 如果B知道Z同学，那就把Z同学的手机号（IP Address）告诉A；

​									-- 如果B也不知道Z同学，那B按同样的搜索方法，可以在自己的通讯录里找到一个离Z更近的C同学（Z、C之间距离小于23），把C同学推荐给A；A同学请求C同学进行下一步查找。

​        Kademlia的这种查询机制，有点像是将一张纸不断地对折来收缩搜索范围，保证对于任意n个学生，最多只需要查询log2(n)次，即可找到获得目标同学的联系方式（即在对于任意一个有[2(n−1), 2n)个节点的网络，最多只需要n步搜索即可找到目标节点）。

​						![947209-1143169c8318a2ff](C:\Users\Administrator\Desktop\Kad\947209-1143169c8318a2ff.png)

上面是所有kad协议的原理

---

下面介绍协议的相关细节：

1、算法参数

```java
1 keysapce
	-- 即ID有多少位，决定每个节点有多少层，以太坊中如 const NodeIDBits = 512
2 k 
	--每个bucket限制最多存储k个节点
3 alpha
	-- 每次向其他node请求查找某个node时，会向α个node发出请求,以太坊为 alpha=3
```

2、节点指令

```java
Kademlia一般节点只有如下指令
	ping       --测试一个节点是否存活
	store      --要求一个节点存储数据
	FIND_NODE  --根据NodeId查找一个节点
	FIND_VALUE --根据key查找一个value，跟FIND_NODE类似
```

3、k-bucket的维护及更新

```java
--每个bucket里的节点都按照最后一次接触到时间倒序排列
--每次执行四个指令中的任意一个都会触发更新
当需要更新一个 kbucket，时 取决于两个因素：
    --kbucket 未满，则直接添加
    --kbucket 已满，则判断是否存在剔除失效节点，存在，则用新节点替换，不存在，则抛弃新节点。
```

##### 3、总结

​		Kademlia是分布式哈希表（Distributed Hash Table, DHT）的一种。而DHT是一类去中心化的分布式系统。在这类系统中，每个节点（node）分别维护一部分的存储内容以及其他节点的路由/地址，使得网络中任何参与者（即节点）发生变更（进入/退出）时，对整个网络造成的影响最小。DHT可以用于构建更复杂的应用，包括分布式文件系统、点对点技术文件分享系统、合作的网页高速缓存、域名系统以及实时通信等。
 Kademlia算法在2002年由Petar Maymounkov 和 David Mazières 所设计，以异或距离来对哈希表进行分层是其特点。Kademlia后来被eMule、BitTorrent等P2P软件采用作为底层算法。Kademlia可以作为信息安全技术的奠基之一。